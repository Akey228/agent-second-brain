---
Created: 2026-01-27T19:18
References:
Tags:
  - info
Links:
  - "[[MOC - Patrick - digital assistant]]"
---
```
"""
desktop_voice_tray.py
Tray-enabled version of your Desktop Voice Recorder.
Place in your project folder and run inside the same venv.

Features:
- Runs with a tray icon (pystray)
- Keeps your existing recording + upload logic
- Global hotkey detection (keyboard)
- Show last logs via tray menu
- Exit from tray
"""

import os
import sys
import time
import tempfile
import threading
import queue
from datetime import datetime

import requests
import sounddevice as sd
import soundfile as sf
import keyboard
import pystray
from pystray import MenuItem as item
from PIL import Image, ImageDraw
import tkinter as tk
from tkinter.scrolledtext import ScrolledText

# === CONFIG ===
WEBHOOK_URL = "https://andratozplay123.app.n8n.cloud/webhook/voice"  # <- your webhook
SAMPLE_RATE = 16000
CHANNELS = 1
SUBTYPE = 'PCM_16'
CHUNK_SIZE = 1024
DEVICE_INDEX = 1  # if None -> default device
UPLOAD_FIELD_NAME = 'file'
HOTKEY_KEYS = ['ctrl', 'shift', 'alt', 'l']  # must match your current combo

# === State & logging ===
is_recording = False
_recording_lock = threading.Lock()
_audio_queue = queue.Queue()
_current_wav_path = None
_stream = None
_writer = None
logs = []  # simple in-memory log (keeps last lines)


def log(msg):
    ts = datetime.now().strftime("%H:%M:%S")
    line = f"[{ts}] {msg}"
    logs.append(line)
    if len(logs) > 200:
        del logs[0]
    print(line)  # still prints to console if run from it


# === audio writer ===
def writer_thread_func(wav_path, samplerate, channels):
    global _writer
    try:
        with sf.SoundFile(wav_path, mode='w', samplerate=samplerate,
                          channels=channels, subtype=SUBTYPE) as f:
            _writer = f
            log(f"Writing audio to: {wav_path}")
            while True:
                try:
                    block = _audio_queue.get(timeout=0.5)
                except queue.Empty:
                    if not is_recording and _audio_queue.empty():
                        break
                    else:
                        continue
                f.write(block)
    except Exception as e:
        log(f"Writer thread error: {e}")
    finally:
        _writer = None
        log("Writer thread ended")


def start_recording():
    global is_recording, _stream, _current_wav_path
    with _recording_lock:
        if is_recording:
            return
        is_recording = True
        fd, path = tempfile.mkstemp(prefix='voice_rec_', suffix='.wav')
        os.close(fd)
        _current_wav_path = path
        t = threading.Thread(target=writer_thread_func, args=(path, SAMPLE_RATE, CHANNELS), daemon=True)
        t.start()
        try:
            _stream = sd.InputStream(samplerate=SAMPLE_RATE, channels=CHANNELS,
                                     callback=audio_callback, blocksize=CHUNK_SIZE,
                                     device=DEVICE_INDEX)
            _stream.start()
            log("Recording started... (release hotkey to stop)")
        except Exception as e:
            log(f"Failed to start input stream: {e}")
            is_recording = False


def stop_recording_and_upload():
    global is_recording, _stream, _current_wav_path
    with _recording_lock:
        if not is_recording:
            return
        is_recording = False
        try:
            if _stream is not None:
                _stream.stop()
                _stream.close()
        except Exception as e:
            log(f"Error stopping stream: {e}")
        log("Finishing write...")
        time.sleep(0.6)
        if _current_wav_path and os.path.exists(_current_wav_path):
            try:
                log(f"Uploading {_current_wav_path} to {WEBHOOK_URL} ...")
                with open(_current_wav_path, 'rb') as f:
                    files = {UPLOAD_FIELD_NAME: (os.path.basename(_current_wav_path), f, 'audio/wav')}
                    resp = requests.post(WEBHOOK_URL, files=files, timeout=60)
                if resp.ok:
                    log(f"Upload success (status code: {resp.status_code})")
                else:
                    log(f"Upload failed (status: {resp.status_code}) {resp.text[:200]}")
            except Exception as e:
                log(f"Upload exception: {e}")
            finally:
                try:
                    os.remove(_current_wav_path)
                except Exception:
                    pass
                _current_wav_path = None
        else:
            log("No audio file to upload.")


# audio callback
def audio_callback(indata, frames, time_info, status):
    if status:
        log(f"Audio status: {status}")
    _audio_queue.put(indata.copy())


# hotkey checker (keeps original check logic)
def check_hotkey_and_update(event=None):
    try:
        all_pressed = all(keyboard.is_pressed(k) for k in HOTKEY_KEYS)
    except Exception:
        all_pressed = False
    if all_pressed and not is_recording:
        start_recording()
    if (not all_pressed) and is_recording:
        stop_recording_and_upload()


# === tray UI ===
def create_image(size=64, color_bg=(20, 20, 20), color_circle=(255, 255, 255)):
    image = Image.new('RGB', (size, size), color_bg)
    dc = ImageDraw.Draw(image)
    dc.ellipse((8, 8, size - 8, size - 8), fill=color_circle)
    return image


# show logs window
def show_logs(icon, item):
    def _show():
        root = tk.Tk()
        root.title("Voice Recorder - Logs")
        root.geometry("640x360")
        text = ScrolledText(root, wrap=tk.WORD)
        text.pack(fill=tk.BOTH, expand=True)
        text.insert(tk.END, "\n".join(logs[-200:]))
        text.configure(state=tk.DISABLED)
        root.mainloop()
    threading.Thread(target=_show, daemon=True).start()


def exit_app(icon, item):
    log("Exiting via tray...")
    try:
        icon.stop()
    except Exception:
        pass
    # ensure recording closed
    if is_recording:
        stop_recording_and_upload()
    sys.exit(0)


def start_keyboard_hook_thread():
    # keyboard.hook installs listener and returns immediately; keep it in separate thread
    def _hook():
        keyboard.hook(check_hotkey_and_update)
        # keep thread alive
        while True:
            time.sleep(1)
    t = threading.Thread(target=_hook, daemon=True)
    t.start()
    log("Keyboard hook thread started")


def main_tray():
    # start keyboard hook
    start_keyboard_hook_thread()
    # create icon
    menu = (item('Show Logs', show_logs), item('Exit', exit_app))
    icon = pystray.Icon("voice_recorder", create_image(), "Voice Recorder", menu)
    log("Tray icon starting...")
    icon.run()  # blocks until icon.stop()


if __name__ == "__main__":
    log("App starting...")
    # optional: list devices if run with arg --list-devices
    if len(sys.argv) > 1 and sys.argv[1] == "--list-devices":
        for i, dev in enumerate(sd.query_devices()):
            print(i, dev['name'], "inputs:", dev['max_input_channels'])
        sys.exit(0)
    try:
        main_tray()
    except Exception as e:
        log(f"Fatal error: {e}")
        raise

```
#### Linked References to "Версия кода с работающим функционалом поверх других окон + трей"
```dataview
list from [[Версия кода с работающим функционалом поверх других окон + трей]]
```